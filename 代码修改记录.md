> `mm-wiki`项目地址：https://github.com/phachon/mm-wiki
>
> 项目最后更新时间: 20250522

# 20211223

## 修改左边侧栏宽度

位置：`/mm-wiki/static/js/modules/common.js`

```
默认230，可以修改为536
// west__size:                 230
west__size:                 536
```

## 修改项目地址

```
https://github.com/phachon/MM-Wiki
替换为
/
```

## 修改mm-wiki

仅仅修改view目录下的的html

```
mm-wiki
替换为
个人wiki库
```

# 20230131

## 文档日志不能正常显示

`app\models\log_document.go`

原代码 - 211行

```
rs, err = db.Query(where.Limit(limit, number).OrderBy("log_document_id", "DESC"))
```

修改为

```
//rs, err = db.Query(where.Limit(limit, number).OrderBy("log_document_id", "DESC"))
rs, err = db.Query(db.AR().From(Table_LogDocument_Name).Limit(limit, number).OrderBy("log_document_id", "DESC"))
```

进入到根目录重编译一下

```
go build ./
```

替换编译后的`mm-wiki`

## mm-wiki升级修复文章名字含有特殊符号

### 禁止使用的特殊字符

```
Windows：
    \ （反斜杠）
    / （斜杠）
    : （冒号）
    * （星号）
    ? （问号）
    " （双引号）
    < （小于号）
    > （大于号）
    | （垂直条）
macOS：
    / （斜杠）
    : （冒号）
Linux：
    / （斜杠）
    \ （反斜杠）
此外，根据跨平台兼容性的要求，建议避免使用以下字符：
    # （井号）
    $ （美元符号）
    % （百分比符号）
    & （与号）
    @ （符号）
    ! （感叹号）
    ( 和 ) （括号）
    [ 和 ] （方括号）
    { 和 } （花括号）
    ^ （caret符号）
    ~ （波浪线）
```

### 完善正则表达式

为了确保正则表达式能够匹配所有禁止使用的特殊字符，包括中文符号和英文标点符号，我们需要逐步完善正则表达式。

**步骤 1：回顾之前的正则表达式**

之前的正则表达式如下：

```
regexp := `[\\/:\*\?"<>|:#$%^&@!()\{\}\[\]~]`
```

**步骤 2：确定需要添加的特殊字符**

为了涵盖更多的禁止字符，特别是中文符号和其他一些特殊情况，我们需要添加以下字符到正则表达式中：

全角符号：

```
全角空格 　
全角引号 「」『』
全角括号 （）
全角句号 。
全角逗号 ，
全角感叹号 ！
全角问号 ？
全角分号 ；
全角冒号 ：
```

其他特殊符号：

```
制表符 \t
换行符 \n
其他特殊的中文符号。
```

**步骤 3：转义特殊字符**

在 Go 的正则表达式中，需要正确处理字符的转义：

反斜杠 \ 在 Go 字符串中使用 \\ 表示，而在正则表达式中，\\ 用于匹配一个反斜杠。
方括号 [ 和 ] 如果需要在字符类中使用，需要放置在适当的位置，或者进行适当的转义，以避免正则表达式解析错误。

**步骤 4：构建新的正则表达式**

在原有正则表达式的基础上，添加新的特殊字符，并确保正确转义。

```
regexp := `[\\/:\*\?"<>|:#$%^&@!()\{\}\[\]~　！？、℃×→＝￥]`
```

解释：

```
\\: 匹配反斜杠 \。
/: 匹配斜杠 /。
:: 匹配冒号 :。
*: 匹配星号 *。
?: 匹配问号 ?。
": 匹配双引号 "。
<: 匹配小于号 <。
>: 匹配大于号 >。
|: 匹配垂直条 |。
#: 匹配井号 #。
$: 匹配美元符号 $。
%: 匹配百分比符号 %。
^: 匹配 caret 符号 ^。
&: 匹配与号 &。
@: 匹配符号 @。
!: 匹配感叹号 !。
( 和 ): 匹配括号。
\{ 和 \}: 匹配花括号。
\[ 和 \]: 匹配方括号。
~: 匹配波浪线 ~。
　: 匹配全角空格。
！: 匹配全角感叹号。
？: 匹配全角问号。
、: 匹配全角逗号。
。: 匹配全角句号。
：: 匹配全角冒号。
「」『』: 匹配全角引号。
（）: 匹配全角括号。
〕〔: 匹配全角方括号。
’‘: 匹配全角单引号。
【】: 匹配全角方括号。
、。: 匹配常见的全角符号。
℃×→＝￥: 匹配特殊的全角符号。
```

### 代码修复

`app\utils\document.go`

```
宽松正则：[\\/:\*\?"<>|]
严格正则：[\\/:\*\?"<>|:#$%^&@!()\{\}\[\]~　！？、℃×→＝￥]

// ... existing code ...

import (
	"regexp"
)
const (
	Document_Default_FileName = "README"
	Document_Page_Suffix      = ".md"
	prohibitedCharsPattern := `[\\/:\*\?"<>|]`
)

// ... existing code ...

在文件最后面创建新函数

// 检查文件名是否包含禁用字符
func containsProhibitedChar(name string) (bool, error) {
    regex := regexp.MustCompile(prohibitedCharsPattern)
    return regex.MatchString(name), nil
}
```

`app\controllers\document.go`

```
修复位置:app\controllers\document.go
修复关键词:文档名称格式不正确！
修复前: 
	match, err := regexp.MatchString(`[\\\\/:*?\"<>、|]`, newName)
	if err != nil {
		this.jsonError("文档名称格式不正确！")
	}
	if match {
		this.jsonError("文档名称格式不正确！")
	}

1、删除page.go和document.go中import导入的"regexp"
import (
	"regexp"
)

2、修复代码：
	// 检查文件名是否包含禁用字符
	match, err := utils.ContainsProhibitedChar(name)
    if err != nil {
        this.jsonError("文档名称格式验证失败！")
    }
    if match {
        this.jsonError("文档名称包含非法字符！")
    }
```

`app\controllers\page.go`

```
修复位置:app\controllers\page.go
修复关键词: 文档名称格式不正确！
修复前: 
	match, err := regexp.MatchString(`[\\\\/:*?\"<>、|]`, newName)
	if err != nil {
		this.jsonError("文档名称格式不正确！")
	}
	if match {
		this.jsonError("文档名称格式不正确！")
	}

1、删除page.go和document.go中import导入的"regexp"
import (
	"regexp"
)

2、修复代码：
	// 检查文件名是否包含禁用字符
	match, err := utils.ContainsProhibitedChar(newName)
    if err != nil {
        this.jsonError("文档名称格式验证失败！")
    }
    if match {
        this.jsonError("文档名称包含非法字符！")
    }
```

`app\modules\system\controllers\space.go`

```
修复位置:app\controllers\space.go
修复关键词: 文档名称格式不正确！
修复前: 
	match, err := regexp.MatchString(`[\\\\/:*?\"<>、|]`, name)
	if err != nil {
		this.jsonError("空间名称格式不正确！")
	}
	if match {
		this.jsonError("空间名称格式不正确！")
	}

1、删除page.go和document.go中import导入的"regexp"
import (
	"regexp"
)

2、修复代码：save()
    // 检查空间名是否包含禁用字符
	match, err := utils.ContainsProhibitedChar(name)
    if err != nil {
        this.jsonError("空间名称格式验证失败！")
    }
    if match {
        this.jsonError("空间名称包含非法字符！以下字符不能使用: \\ / : * ? \" < > |")
    }
2、修复代码：Modify()
    // 检查空间名是否包含禁用字符
	match, err := utils.ContainsProhibitedChar(name)
    if err != nil {
        this.jsonError("空间名称格式验证失败！")
    }
    if match {
        this.jsonError("空间名称包含非法字符！以下字符不能使用: \\ / : * ? \" < > |")
    }
```

静态显示

```
修复位置:
    views\document\form.html
    views\system\space\form.html
修复前：
	* 不能包含 \ / : * ? " < > | 、非法字符
修复后：
	* 不能包含 \ / : * ? " < > | 非法字符
```

# 20250321

## 通过API检查父文档有效性

在`app\controllers\document.go`新建一个函数`CheckParent`和`ValidateParentDocument`

```
// 全面验证父文档的有效性
func (this *DocumentController) ValidateParentDocument(parentId string, spaceId string) (bool, map[string]string, error) {
    // 验证空间ID
    if spaceId == "" || spaceId == "0" {
        return false, nil, fmt.Errorf("无效的空间ID")
    }
    if parentId == "" || parentId == "0" {
        return false, nil, fmt.Errorf("没有选择父文档")
    }
    // 验证空间是否存在
    space, err := models.SpaceModel.GetSpaceBySpaceId(spaceId)
    if err != nil {
        return false, nil, fmt.Errorf("获取空间信息失败: %s", err.Error())
    }
    if len(space) == 0 {
        return false, nil, fmt.Errorf("空间不存在")
    }
    
    // 检查访问权限
    isVisit, _, _ := this.GetDocumentPrivilege(space)
    if !isVisit {
        return false, nil, fmt.Errorf("您没有权限访问该空间")
    }

    // 父文档有效性验证
    // 获取父文档信息
    parentDoc, err := models.DocumentModel.GetDocumentByDocumentId(parentId)
    if err != nil {
        return false, nil, fmt.Errorf("获取父文档信息失败: %s", err.Error())
    }
    // 检查父文档是否存在
    if len(parentDoc) == 0 {
        return false, nil, fmt.Errorf("父文档不存在")
    }
    // 验证父文档是否属于指定空间
    if parentDoc["space_id"] != spaceId {
        return false, nil, fmt.Errorf("父文档不属于当前空间")
    }
    // 验证指定的父ID是否为目录类型
    if parentDoc["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        return false, nil, fmt.Errorf("指定的父级不是目录")
    }
    return true, space, nil
}

// 通过API检查父文档有效性
func (this *DocumentController) CheckParent() {
    // 获取参数
    spaceId := this.GetString("space_id", "0")
    parentId := this.GetString("parent_id", "0")
    
    // 全面验证父文档的有效性
    isValid, _, err := this.ValidateParentDocument(parentId, spaceId)
    if !isValid {
        this.jsonError(err.Error())
        return
    }
    
    // 返回成功结果
    this.jsonSuccess("验证成功", map[string]interface{}{
        "is_valid": true,
    }, "")
}
```

### 调用方式

1. 发送 POST 请求到 `/document/MoveDirectory`

2. 参数：
   - `parent_id`: 父目录 ID，如果不传则默认为"0"。如果传入 parentId 为 "0" ，则相当于获取整个空间下的所有文档。

   - `space_id`: 空间 ID


示例调用

```
# 正常情况：核心功能检查目录456是否属于123空间，用于批量导入时检查，后续功能也基本是指定目录，因此代码中添加了验证指定的父ID是否为目录类型
curl -X GET http://localhost:8080/document/checkParent -d "space_id=123&parent_id=456"

```

### 返回结果示例

成功时：

```
{
    "code": 0,
    "message": "验证成功",
    "data": {
        "is_valid": true
    }
}
```

失败时：

```
{
    "code": 1,
    "message": "错误信息（例如：父文档不存在）",
    "data": null
}
```

## 获取空间下所有文档ID及数量（可指定父目录）

现有mw_document表数据结构及部分示例数据

```
document_id 文档 id
parent_id  文档父 id
space_id   空间id
name   文档类型 1 page 2 dir
path   存储根文档到父文档的 document_id 值, 格式 0,1,2,...

document_id parent_id  space_id   name   type   path
3835   3834   1  1  2  0,1,3834
3836   3834   1  2  2  0,1,3834
3837   3836   1  1  1  0,1,3834,3836
3838   3835   1  3  1  0,1,3834,3835
3839   3834   1  3  2  0,1,3834
3840   3839   1  4  2  0,1,3834,3839
3841   3840   1  2  1  0,1,3834,3839,3840
```

1、参考` app\models\document.go` 数据库实现方法, 输入空间ID, 输出该空间下所有目录、目录下文档及子目录和子目录下文档、子目录下子目录和相应文档等等的所有文档ID, 并返回所有目录和文档的数量

2、在 `app\controllers\document.go`中实现该方法

导入模块

```
import (
	"strconv"
)
```

在`app\controllers\document.go`创建查询函数

```
// 获取空间下所有文档ID
func (this *DocumentController) GetInSpaceDocumentId(spaceId string, parentId string) (documentIds []string, total int, err error) {
    
    // 如果父文档ID不为0，先添加父文档ID
    if parentId != "0" {
        documentIds = append(documentIds, parentId)
        total++
    }

    // 获取空间下指定父文档的所有文档
    documents, err := models.DocumentModel.GetDocumentsBySpaceIdAndParentId(spaceId, parentId)
    if err != nil {
        return
    }

    // 递归获取所有子文档
    var getAllSubDocuments func(parentId string) error
    getAllSubDocuments = func(parentId string) error {
        // 获取当前目录下的所有文档
        subDocuments, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return err
        }

        for _, doc := range subDocuments {
            documentIds = append(documentIds, doc["document_id"])
            total++

            // 如果是目录，递归获取子文档
            if doc["type"] == strconv.Itoa(models.Document_Type_Dir) {
                err = getAllSubDocuments(doc["document_id"])
                if err != nil {
                    return err
                }
            }
        }
        return nil
    }

    // 从指定父文档开始遍历
    for _, doc := range documents {
        documentIds = append(documentIds, doc["document_id"])
        total++

        // 如果是目录，递归获取子文档
        if doc["type"] == strconv.Itoa(models.Document_Type_Dir) {
            err = getAllSubDocuments(doc["document_id"])
            if err != nil {
                return
            }
        }
    }

    return
}

// 获取空间下所有文档ID及数量
func (this *DocumentController) GetAllDocumentIdsInSpace() {
    spaceId := this.GetString("space_id", "0")
    parentId := this.GetString("parent_id", "0")

    // 全面验证父文档的有效性
    isValid, _, err := this.ValidateParentDocument(parentId, spaceId)
    if !isValid {
        this.jsonError(err.Error())
        return
    }

    // 获取所有文档ID
    documentIds, total, err := this.GetInSpaceDocumentId(spaceId, parentId)
    if err != nil {
        this.jsonError(fmt.Sprintf("获取文档列表失败: %s", err.Error()))
        return
    }
    // 检查是否有文档
    if len(documentIds) == 0 {
        this.jsonSuccess("success", map[string]interface{}{
            "document_ids": []string{},
            "total":        0,
            "empty":        true,
        }, "")
        return
    }

    this.jsonSuccess("success", map[string]interface{}{
        "document_ids": documentIds,
        "total":        total,
    }, "")
}
```



### 调用方式

1. 发送 GET请求到 `/document/getAllDocumentIdsInSpace`

2. 参数：
   - `parent_id`: 父目录 ID，如果不传则默认为"0"。如果传入 parentId 为 "0" ，则相当于获取整个空间下的所有文档。
   
   - `space_id`: 空间 ID

示例调用：

```bash
curl "http://localhost:8080/document/getAllDocumentIdsInSpace?space_id=1&parent_id=2"
```



## 递归删除目录下的所有目录和文件

在`app\controllers\document.go`新建一个函数`DeleteAllDocumentIdsInSpace`

```
// 删除空间下所有文档ID及数量（可指定父文档）
func (this *DocumentController) DeleteAllDocumentIdsInSpace() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    spaceId := this.GetString("space_id", "0")
    parentId := this.GetString("parent_id", "0")
    confirm := this.GetString("confirm", "false") // 添加确认参数
    deleteParent := this.GetString("delete_parent", "true")  // 添加新参数，默认为 "true"
    
    // 全面验证父文档的有效性
    isValid, space, err := this.ValidateParentDocument(parentId, spaceId)
    if !isValid {
        this.jsonError(err.Error())
        return
    }

    // 获取所有文档ID
    documentIds, total, err := this.GetInSpaceDocumentId(spaceId, parentId)
    if err != nil {
        this.jsonError(err.Error())
        return
    }

    // 如果不删除父文档，从documentIds中移除parentId
    if deleteParent == "false" && parentId != "0" {
        for i, id := range documentIds {
            if id == parentId {
                documentIds = append(documentIds[:i], documentIds[i+1:]...)
                total--
                break
            }
        }
    }
    // 如果没有确认，返回需要删除的文档数量和提示
    if confirm != "true" {
        // 获取父文档信息
        var parentInfo map[string]string
        if parentId != "0" {
            parentInfo, err = models.DocumentModel.GetDocumentByDocumentId(parentId)
            if err != nil {
                this.jsonError(fmt.Sprintf("获取父文档信息失败: %s", err.Error()))
                return
            }
        }
		parentName := "根目录"
        if parentInfo != nil {
            parentName = parentInfo["name"]
        }

        this.jsonSuccess("请确认删除操作", map[string]interface{}{
            "total":        total,
            "space_name":   space["name"],
            "space_id":     spaceId,
            "parent_id":    parentId,
            "parent_name":  parentName,
            "need_confirm": true,
        }, "")
        return
    }

    // 删除所有文档
    deletedCount := 0
    for _, documentId := range documentIds {
        document, err := models.DocumentModel.GetDocumentByDocumentId(documentId)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取文档 %s 信息失败: %s", documentId, err.Error()))
            return
        }
        if len(document) == 0 {
            continue
        }

        // 跳过空间根目录
        if document["parent_id"] == "0" {
            continue
        }

        _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(document)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取文档 %s 文件路径失败: %s", documentId, err.Error()))
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(documentId, spaceId, this.UserId, pageFile, document["type"])
        if err != nil {
            this.jsonError(fmt.Sprintf("删除文档 %s 失败: %s", documentId, err.Error()))
            return
        }
        deletedCount++
    }

    this.jsonSuccess("删除成功", map[string]interface{}{
        "deleted_count": deletedCount,
        "space_id":     spaceId,
        "space_name":   space["name"],
        "parent_id":    parentId,
    }, "")
}
```

### 调用方式

1. 

2. 在未确认时返回需要删除的文档数量和空间名称，让用户明确知道将要删除的内容

3. 添加了 delete_parent可选参数，当 deleteParent 为 `false` 时，将保留父目录但删除其下的所有文档；当 deleteParent 为 `true` 时，将连同父目录一起删除。

4. 发送 POST 请求到 `/document/deleteAllDocumentIdsInSpace`

5. 参数：
   - `parent_id`: 父目录 ID

     如果不传则默认为"0"。如果传入 parentId 为 "0" ，则相当于获取整个空间下的所有文档。

   - `space_id`: 空间 ID

   - `confirm`: 是否执行删除操作（可选，默认为 false）

     在未确认时返回需要删除的文档数量和空间名称，让用户明确知道将要删除的内容

   - `delete_parent`: 是否保留父目录（可选，默认为 true）

     当 deleteParent 为 `false` 时，将保留父目录但删除其下的所有文档；

     当 deleteParent 为 `true` 时，将连同父目录一起删除。

示例调用：
第一次调用（获取删除信息）：

```bash
curl -X POST "http://localhost:8080/document/deleteAllDocumentIdsInSpace" -d "space_id=1&parent_id=2"
```
确认删除：

```bash
curl -X POST "http://localhost:8080/document/DeleteAllDocumentIdsInSpace" -d "space_id=1&parent_id=2&confirm=true"
```
这样设计可以防止误操作，确保用户明确知道将要删除的内容，并需要显式确认才能执行删除操作。

不删除父目录

```bash
# 如指定pid为222，会删除222内所有目录和文档，但不会删除父目录222，这个可以加入参数选择，默认不删除222
curl -X POST "http://localhost:8080//document/DeleteAllDocumentIdsInSpace?space_id=1&parent_id=4026&confirm=true&delete_parent=false"
```



# 20250412



## 移动目录数据

```
	修复位置: app\controllers\document.go
	修复关键词: 文档名称格式不正确！
	修复方法: 注释下面代码
if moveType != "next" && moveType != "prev" {
		if document["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
			this.jsonError("不能移动文档目录！")
		}
	}
```

这仅仅修改了后端代码，不能直接拖动，但可以通过发送数据包完成移动，如下：

```
将3740目录移动到3735下面

发送空POST数据包请求: /document/move?document_id=3740&target_id=3735
```

移动完成后服务器中相关目录也会进行移动，但移动后数据库索引没有改变，后续代码主要卡在索引这一步了。

先拿个简版凑合用用吧

### 移动所有目录和文档

在`app\controllers\document.go`新建一个函数`MoveDirectory`

```
// move document directory
func (this *DocumentController) MoveDirectory() {
	// 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    onlyDocs, _ := this.GetBool("only_docs", false)  // 添加新参数，默认为false

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }
    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 只有在不是仅移动文档的情况下才检查子目录
    if !onlyDocs {
        // 获取目标目录的完整路径信息
        targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
        for _, pathId := range targetPath {
            if pathId == sourceId {
                this.jsonError("不能将目录移动到其子目录中！")
            }
        }
        
        // 递归检查子目录
        var checkSubDirectories func(parentId string) error
        checkSubDirectories = func(parentId string) error {
            subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
            if err != nil {
                return err
            }
            for _, doc := range subDocs {
                if doc["document_id"] == targetId {
                    return fmt.Errorf("目标目录是源目录的子目录")
                }
                if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    if err := checkSubDirectories(doc["document_id"]); err != nil {
                        return err
                    }
                }
            }
            return nil
        }
        
        if err := checkSubDirectories(sourceId); err != nil {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents": 0,
        "directories": 0,
        "skipped": 0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
            // 如果只移动文档且当前项是目录，则跳过
            if onlyDocs && doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                movedStats["skipped"]++
                continue
            }

            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"], 
                targetId, 
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]
                
                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newPath := targetPath + "," + targetId
                        err = moveRecursively(subDocs, utils.Convert.IntToString(newDirId, 10), newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录前检查是否还有文档
                subDocs, err := models.DocumentModel.GetDocumentsByParentId(sourceDirectoryId)
                if err != nil {
                    return fmt.Errorf("检查源目录文档失败: %v", err)
                }
                if len(subDocs) > 0 {
                    this.InfoLog(fmt.Sprintf("目录 %s 中还有文档，跳过删除", sourceDirectoryId))
                    continue
                }
            
                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
            
                continue
            }

            // 处理文档：如果存在同名文档，添加时间戳后缀
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            // 处理文档
            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "name":         doc["name"],
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"], 
                targetSpaceId, 
                updateValue,
                oldPageFile, 
                newPageFile, 
                doc["type"], 
                "移动文档到 " + targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, targetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        // 添加更详细的错误信息到响应
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 移动完成后删除源目录
    _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
    if err != nil {
        this.ErrorLog("获取源目录文件失败：" + err.Error())
        this.jsonError(fmt.Sprintf("获取源目录文件失败：%s", err.Error()))
        return
    }
    
    // 检查源目录是否还有文档
    remainingDocs, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("检查源目录文档失败：" + err.Error())
        this.jsonError("检查源目录文档失败")
        return
    }
    if len(remainingDocs) > 0 {
        this.InfoLog(fmt.Sprintf("源目录 %s 中还有文档，跳过删除", sourceId))
        this.jsonSuccess("移动目录成功，源目录因还有文档而保留", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
            "warning": "源目录中还有文档，已保留",
        }, "/document/index?document_id="+targetId)
        return
    }

    // 添加源目录存在性检查
    checkDoc, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("检查源目录失败：" + err.Error())
        this.jsonError("检查源目录失败")
        return
    }
    if len(checkDoc) == 0 {
        this.InfoLog("源目录已被删除，跳过删除步骤")
        this.jsonSuccess("移动目录成功", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
        }, "/document/index?document_id="+targetId)
        return
    }
    
    err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
    if err != nil {
        this.ErrorLog("删除源目录失败：" + err.Error())
        // 即使删除源目录失败，移动操作已经完成，返回成功
        this.jsonSuccess("移动目录成功，但删除源目录失败", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
            "warning": "源目录删除失败：" + err.Error(),
        }, "/document/index?document_id="+targetId)
        return
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录", 
        sourceId, 
        movedStats["documents"], 
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents": movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "source_space": sourceSpace["name"],
        "target_space": targetSpace["name"],
    }, "/document/index?document_id="+targetId)
}
```

#### 调用方式

1. 发送 POST 请求到 `/document/MoveDirectory`

2. 参数：
   - `source_id`: 源目录ID
   
   - `target_id`: 目标目录 ID
   
   - `only_docs`: 是否仅移动文档（可选，默认为 false）

示例调用

```bash
# 正常情况：将目录123移动到目录456下，移动完成后删除源目录，如果源目录与目标目录有项目名称文件则会跳过并无法删除源目录
curl -X POST http://localhost:8080/document/MoveDirectory -d "source_id=123&target_id=456"

# 仅移动目录内的文档到另一个目录，如果目录内存在子目录则直接跳过
# 默认是不允许将目录移动到其子目录中，这可能将造成循环引用的问题，但如果选择仅移动文档的话是允许的
curl -X POST http://localhost:8080/document/MoveDirectory -d "source_id=123&target_id=456&only_docs=true"
```

### 移动所有目录和文档-指定模式（有bug）

```
我希望将目录aaaa移动到目录BBB下，有两种情况
1、将aaaa内所有子目录及文档移动到BBB下，目前已经实现
2、将aaaa目录包含本身及其子目录和文档移动到BBB下，索引问题暂未实现
```

在`app\controllers\document.go`新建一个函数`MoveDirectoryAll`

#### v1版本

```
// move document directory all
func (this *DocumentController) MoveDirectoryAll() {
	// 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    onlyDocs, _ := this.GetBool("only_docs", false)  // 添加可选参数，默认为false
    moveMode := this.GetString("move_mode", "content") // 移动模式：content-仅移动内容，all-移动目录及内容

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }
    if moveMode != "content" && moveMode != "all" {
        this.jsonError("无效的移动模式！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }

    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 只有在不是仅移动文档的情况下才检查子目录
    if !onlyDocs {
        // 获取目标目录的完整路径信息
        targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
        for _, pathId := range targetPath {
            if pathId == sourceId {
                this.jsonError("不能将目录移动到其子目录中！")
            }
        }
        
        // 递归检查子目录
        var checkSubDirectories func(parentId string) error
        checkSubDirectories = func(parentId string) error {
            subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
            if err != nil {
                return err
            }
            for _, doc := range subDocs {
                if doc["document_id"] == targetId {
                    return fmt.Errorf("目标目录是源目录的子目录")
                }
                if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    if err := checkSubDirectories(doc["document_id"]); err != nil {
                        return err
                    }
                }
            }
            return nil
        }
        
        if err := checkSubDirectories(sourceId); err != nil {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }

    // 如果是移动整个目录，先创建源目录在目标位置
    var newTargetId string = targetId
    if moveMode == "all" {
        // 检查目标位置是否存在同名目录
        existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
            sourceDocument["name"],
            targetId,
            targetSpaceId,
            models.Document_Type_Dir)
        if err != nil {
            this.ErrorLog("检查目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        if len(existingDoc) > 0 {
            this.jsonError("目标位置已存在同名目录！")
        }

        // 创建新目录
        insertDoc := map[string]interface{}{
            "parent_id":      targetId,
            "space_id":       targetSpaceId,
            "name":           sourceDocument["name"],
            "type":           models.Document_Type_Dir,
            "path":           targetDocument["path"] + "," + targetId,
            "create_user_id": this.UserId,
            "edit_user_id":   this.UserId,
        }
        newDirId, err := models.DocumentModel.Insert(insertDoc)
        if err != nil {
            this.ErrorLog("创建目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        newTargetId = utils.Convert.IntToString(newDirId, 10)
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents":    0,
        "directories": 0,
        "skipped":     0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
        	// 如果只移动文档且当前项是目录，则跳过
            if onlyDocs && doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                movedStats["skipped"]++
                continue
            }
            
            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"],
                targetId,
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]

                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                    movedStats["skipped"]++
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newPath := targetPath + "," + targetId
                        err = moveRecursively(subDocs, utils.Convert.IntToString(newDirId, 10), newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
                continue
            }

            // 处理文档
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"],
                targetSpaceId,
                updateValue,
                oldPageFile,
                newPageFile,
                doc["type"],
                "移动文档到 "+targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, newTargetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 如果是仅移动内容模式，删除源目录
    if moveMode == "content" {
        _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
        if err != nil {
            this.ErrorLog("获取源目录文件失败：" + err.Error())
            this.jsonError("获取源目录文件失败")
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
        if err != nil {
            this.ErrorLog("删除源目录失败：" + err.Error())
            this.jsonError("删除源目录失败")
            return
        }
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录",
        sourceId,
        movedStats["documents"],
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents":    movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "skipped":          movedStats["skipped"],
        "source_space":     sourceSpace["name"],
        "target_space":     targetSpace["name"],
        "move_mode":        moveMode,
    }, "/document/index?document_id="+newTargetId)
}

```

#### v2版本

```
// move document directory all
func (this *DocumentController) MoveDirectoryAll() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    moveMode := this.GetString("move_mode", "content") // 移动模式：content-仅移动内容，all-移动目录及内容

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }
    if moveMode != "content" && moveMode != "all" {
        this.jsonError("无效的移动模式！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }

    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 获取目标目录的完整路径信息
    targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
    for _, pathId := range targetPath {
        if pathId == sourceId {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }
    
    // 递归检查子目录
    var checkSubDirectories func(parentId string) error
    checkSubDirectories = func(parentId string) error {
        subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return err
        }
        for _, doc := range subDocs {
            if doc["document_id"] == targetId {
                return fmt.Errorf("目标目录是源目录的子目录")
            }
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                if err := checkSubDirectories(doc["document_id"]); err != nil {
                    return err
                }
            }
        }
        return nil
    }
    
    if err := checkSubDirectories(sourceId); err != nil {
        this.jsonError("不能将目录移动到其子目录中！")
    }

    // 如果是移动整个目录，先创建源目录在目标位置
    var newTargetId string = targetId
    if moveMode == "all" {
        // 检查目标位置是否存在同名目录
        existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
            sourceDocument["name"],
            targetId,
            targetSpaceId,
            models.Document_Type_Dir)
        if err != nil {
            this.ErrorLog("检查目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        if len(existingDoc) > 0 {
            this.jsonError("目标位置已存在同名目录！")
        }

        // 创建新目录
        insertDoc := map[string]interface{}{
            "parent_id":      targetId,
            "space_id":       targetSpaceId,
            "name":           sourceDocument["name"],
            "type":           models.Document_Type_Dir,
            "path":           targetDocument["path"] + "," + targetId,
            "create_user_id": this.UserId,
            "edit_user_id":   this.UserId,
        }
        newDirId, err := models.DocumentModel.Insert(insertDoc)
        if err != nil {
            this.ErrorLog("创建目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        newTargetId = utils.Convert.IntToString(newDirId, 10)
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents":    0,
        "directories": 0,
        "skipped":     0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"],
                targetId,
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]

                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                    movedStats["skipped"]++
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newDirIdStr := utils.Convert.IntToString(newDirId, 10)
                        newPath := targetPath + "," + targetId + "," + newDirIdStr
                        err = moveRecursively(subDocs, newDirIdStr, newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
                continue
            }

            // 处理文档
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"],
                targetSpaceId,
                updateValue,
                oldPageFile,
                newPageFile,
                doc["type"],
                "移动文档到 "+targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, newTargetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 递归更新所有文档的索引
    var updateIndexRecursively func(docs []map[string]string) error
    updateIndexRecursively = func(docs []map[string]string) error {
        for _, doc := range docs {
            // 获取最新的文档信息
            updatedDoc, err := models.DocumentModel.GetDocumentByDocumentId(doc["document_id"])
            if err != nil {
                return err
            }
            if len(updatedDoc) > 0 {
                // 更新当前文档的索引
                services.DocIndexService.UpdateDocIndex(updatedDoc)

                // 如果是目录，获取其下所有文档
                if updatedDoc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(updatedDoc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = updateIndexRecursively(subDocs)
                        if err != nil {
                            return err
                        }
                    }
                }
            }
        }
        return nil
    }

    // 开始更新索引
    if moveMode == "all" {
        // 获取新目录下的所有文档
        newDocs, err := models.DocumentModel.GetDocumentsByParentId(newTargetId)
        if err != nil {
            this.ErrorLog("获取新目录文档失败：" + err.Error())
        } else {
            // 先更新目标目录本身
            targetDoc, _ := models.DocumentModel.GetDocumentByDocumentId(newTargetId)
            if len(targetDoc) > 0 {
                services.DocIndexService.UpdateDocIndex(targetDoc)
            }
            // 更新所有子文档
            err = updateIndexRecursively(newDocs)
            if err != nil {
                this.ErrorLog("更新文档索引失败：" + err.Error())
            }
        }
    } else {
        // content 模式下更新目标目录下的文档
        targetDocs, err := models.DocumentModel.GetDocumentsByParentId(targetId)
        if err != nil {
            this.ErrorLog("获取目标目录文档失败：" + err.Error())
        } else {
            err = updateIndexRecursively(targetDocs)
            if err != nil {
                this.ErrorLog("更新文档索引失败：" + err.Error())
            }
        }
    }
    // 如果是仅移动内容模式，删除源目录
    if moveMode == "content" {
        _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
        if err != nil {
            this.ErrorLog("获取源目录文件失败：" + err.Error())
            this.jsonError("获取源目录文件失败")
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
        if err != nil {
            this.ErrorLog("删除源目录失败：" + err.Error())
            this.jsonError("删除源目录失败")
            return
        }
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录",
        sourceId,
        movedStats["documents"],
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents":    movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "skipped":          movedStats["skipped"],
        "source_space":     sourceSpace["name"],
        "target_space":     targetSpace["name"],
        "move_mode":        moveMode,
    }, "/document/index?document_id="+newTargetId)
}
```

#### 调用方式

1. 发送 POST 请求到 `/document/MoveDirectoryAll`

2. 参数：
   - `source_id`: 源目录ID
   
   - `target_id`: 目标目录 ID
   
   - `move_mode `: 移动模式（可选，默认为 content）
   
     content：将123内的所有内容移动到456并删除123目录
   
     all：将123目录包含本身及其子目录和文档移动到456下

示例调用

```bash
# 正常情况：将目录123移动到目录456下
curl -X POST http://localhost:8080/document/MoveDirectoryAll -d "source_id=123&target_id=456&move_mode=all"
```

#### bug

- content正常使用
- 选择all模式时，索引异常-未解决



## 数据库中mw_document表 path 字段的长度限制

原本30，调整为150

相应sql命令

```
ALTER TABLE mw_document MODIFY COLUMN path CHAR(150);
```

# 20250426

## 对指定目录下的文档和目录进行排序

在`app\controllers\document.go`新建一个函数`SortDocuments`

```
// 按名称对指定父文档下的文档和目录进行排序
func (this *DocumentController) SortDocuments() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    
    // 获取参数
    parentId := this.GetString("parent_id", "0")
    spaceId := this.GetString("space_id", "0")
    recursive, _ := this.GetBool("recursive", false)  // 是否递归排序子目录
    
    // 全面验证父文档的有效性
    isValid, _, err := this.ValidateParentDocument(parentId, spaceId)
    if !isValid {
        this.jsonError(err.Error())
        return
    }
    
    // 定义递归排序函数
    var sortDocumentsRecursively func(parentId string) (int, error)
    sortDocumentsRecursively = func(parentId string) (int, error) {
        // 获取父文档下的所有文档
        documents, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return 0, err
        }
        
        // 按类型和名称排序：先目录后文档，每种类型内按名称排序
        dirDocs := []map[string]string{}
        pageDocs := []map[string]string{}
        
        // 分离目录和文档
        for _, doc := range documents {
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                dirDocs = append(dirDocs, doc)
            } else {
                pageDocs = append(pageDocs, doc)
            }
        }
        
        // 对目录按名称排序
        sort.Slice(dirDocs, func(i, j int) bool {
            return strings.ToLower(dirDocs[i]["name"]) < strings.ToLower(dirDocs[j]["name"])
        })
        
        // 对文档按名称排序
        sort.Slice(pageDocs, func(i, j int) bool {
            return strings.ToLower(pageDocs[i]["name"]) < strings.ToLower(pageDocs[j]["name"])
        })
        
        // 合并排序后的目录和文档
        sortedDocs := append(dirDocs, pageDocs...)
        
        // 更新文档的sequence字段
        for i, doc := range sortedDocs {
            sequence := i + 1 // 序号从1开始
            _, err := models.DocumentModel.Update(doc["document_id"], map[string]interface{}{
                "sequence": sequence,
                "edit_user_id": this.UserId,
            }, fmt.Sprintf("修改文档排序"), spaceId)
            if err != nil {
                return 0, err
            }
        }
        
        // 如果需要递归排序，则处理所有子目录
        totalSorted := len(sortedDocs)
        if recursive {
            for _, doc := range dirDocs {
                // 递归处理子目录
                subSorted, err := sortDocumentsRecursively(doc["document_id"])
                if err != nil {
                    return 0, err
                }
                totalSorted += subSorted
            }
        }
        
        return totalSorted, nil
    }
    
    // 执行排序
    totalSorted, err := sortDocumentsRecursively(parentId)
    if err != nil {
        this.ErrorLog("文档排序失败：" + err.Error())
        this.jsonError("文档排序失败！")
        return
    }
    
    this.InfoLog("文档排序成功，共排序 " + strconv.Itoa(totalSorted) + " 个文档")
    this.jsonSuccess("文档排序成功", map[string]interface{}{
        "count": totalSorted,
        "recursive": recursive,
    }, "")
}
```

### 调用方式

1. 发送 POST 请求到 `/document/SortDocuments`
2. 参数：
   - `parent_id`: 父目录 ID
   - `space_id`: 空间 ID
   - `recursive`: 是否递归排序子目录（可选，默认为 false）

示例调用：

```bash
# 基本的文档排序
curl -X POST "http://localhost:8080/document/SortDocuments" -d "space_id=1&parent_id=2"

# 递归处理子目录，先显示目录，再显示文档，每种类型内部按名称字母顺序排序
curl -X POST "http://localhost:8080/document/SortDocuments" -d "space_id=1&parent_id=2&recursive=true"
```

# 20250428

## 图片信息保存失败

根据错误信息 ` 上传图片保存信息错误: Error 1406: Data too long for column 'name' at row 1` ，这是一个典型的MySQL数据库错误，表示您尝试插入的数据超过了数据库表中'name'列的最大长度限制。

在 `image.go` 文件中，当上传图片时，系统会将图片的原始文件名直接存储到数据库的 attachment 表的 name 字段中

```
attachment := map[string]interface{}{
    "user_id":     this.UserId,
    "document_id": documentId,
    "name":        h.Filename,  // 这里直接使用了原始文件名
    "path":        fmt.Sprintf("images/%s/%s/%s", spaceId, documentId, h.Filename),
    "source":      models.Attachment_Source_Image,
}
```

问题在于，用户上传的图片文件名可能非常长，超过了数据库 name 字段的长度限制。

改进：

- 1、生成一个唯一的文件名，而不是使用原始文件名

`app\controllers\image.go`

导入所需模块

```
import (
	"time"	// 添加time包的导入
	"math/rand" // 添加随机数包
)
```

添加代码

```
// ... existing code ...
	// handle upload
	f, h, err := this.GetFile("editormd-image-file")
	if err != nil {
		this.ErrorLog("上传图片数据错误: " + err.Error())
		this.jsonError("上传图片数据错误")
		return
	}
	if h == nil || f == nil {
		this.ErrorLog("上传图片错误")
		this.jsonError("上传图片错误")
		return
	}
	_ = f.Close()

	// 生成唯一文件名
	ext := path.Ext(h.Filename)
	// 使用时间戳+随机字符串生成唯一文件名，文件名格式为： 时间戳_随机字符串.扩展名
	rand.Seed(time.Now().UnixNano())
	const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	randomStr := make([]byte, 6)  // 将长度从4改为6
	for i := 0; i < 6; i++ {      // 将循环次数从4改为6
		randomStr[i] = chars[rand.Intn(len(chars))]
	}
	
	uniqueFilename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), string(randomStr), ext)

	// file save dir
	saveDir := fmt.Sprintf("%s/%s/%s", app.ImageAbsDir, spaceId, documentId)
	ok, _ := utils.File.PathIsExists(saveDir)
	if !ok {
		err := os.MkdirAll(saveDir, 0777)
		if err != nil {
			this.ErrorLog("上传图片错误: " + err.Error())
			this.jsonError("上传图片失败")
			return
		}
	}
	// check file is exists
	imageFile := path.Join(saveDir, uniqueFilename)
	ok, _ = utils.File.PathIsExists(imageFile)
	if ok {
		this.jsonError("该图片已经上传过！")
	}
	// save file
	err = this.SaveToFile("editormd-image-file", imageFile)
	if err != nil {
		this.ErrorLog("图片保存失败: " + err.Error())
		this.jsonError("图片保存失败")
	}

	// insert db
	attachment := map[string]interface{}{
		"user_id":     this.UserId,
		"document_id": documentId,
		"name":        uniqueFilename,
		"path":        fmt.Sprintf("images/%s/%s/%s", spaceId, documentId, uniqueFilename),
		"source":      models.Attachment_Source_Image,
	}
```

- 2、修改数据库表结构

  修改数据库中`mw_attachment`表 `name`  字段的长度限制

  原本50，调整为150
  
  ```
  ALTER TABLE mw_attachment MODIFY COLUMN name VARCHAR(150);
  ```
  
  

## 附件显示图片名称

`views\attachment\image.html`

```
// ... existing code ...
<td class="text-left"><strong>图片</strong></td>
<td class="w15p text-left"><strong>名称</strong></td>
<td class="w15p text-left"><strong>上传用户</strong></td>
<td class="w20p text-left"><strong>上传时间</strong></td>
<td class="w11p center"><strong>操作</strong></td>

// ... existing code ...
<td>{{$attachment.name}}</td>
<td>{{$attachment.username}}</td>
<td>{{dateFormat $attachment.create_time "Y-m-d H:i:s"}}</td>
// ... existing code ...
```


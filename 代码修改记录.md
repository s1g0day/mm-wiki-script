> `mm-wiki`项目地址：https://github.com/phachon/mm-wiki
> 
> 项目最后更新时间: 20250313

# 20211223

## 修改左边侧栏宽度

位置：`/mm-wiki/static/js/modules/common.js`

```
默认230，可以修改为536
// west__size:                 230
west__size:                 536
```

## 修改项目地址

```
https://github.com/phachon/MM-Wiki
替换为
/
```

## 修改mm-wiki

仅仅修改view目录下的的html

```
mm-wiki
替换为
个人wiki库
```

# 20230131

## 文档日志不能正常显示

`app\models\log_document.go`

原代码 - 211行

```
rs, err = db.Query(where.Limit(limit, number).OrderBy("log_document_id", "DESC"))
```

修改为

```
//rs, err = db.Query(where.Limit(limit, number).OrderBy("log_document_id", "DESC"))
rs, err = db.Query(db.AR().From(Table_LogDocument_Name).Limit(limit, number).OrderBy("log_document_id", "DESC"))
```

进入到根目录重编译一下

```
go build ./
```

替换编译后的`mm-wiki`

## mm-wiki升级修复文章名字含有特殊符号

```
修复位置: app\controllers\page.go、app\controllers\document.go
修复关键词: 文档名称格式不正确！
修复代码: 
    match, err := regexp.MatchString(`[\\\\/:*?\"<>、|]`, name)
    match, err := regexp.MatchString(`[\\\\/:*?\"<>、|]`, newName)
文章和目录名称不能包含` \ / : * ? " < > | 、`非法字符

代码回退: 部分文章因文件名含有 / 符号, 被linux当作目录符创建了目录
    建议：
        方法1: 编写脚本爬取所有文章名字, 查看符合条件的目录是否存在异常, 与`文章内容缺失`检测脚本合并处理
        方法2: 接通过数据库文件搜索
        方法3: 逐个查看文档目录

windows下不能使用的字符 9个: ` \  /  :  *  ?  "  <  >  |`
linux下不能使用的字符` / `
```

# 20250321

## 获取空间下所有文档ID及数量（可指定父目录）

现有mw_document表数据结构及部分示例数据

```
document_id 文档 id
parent_id  文档父 id
space_id   空间id
name   文档类型 1 page 2 dir
path   存储根文档到父文档的 document_id 值, 格式 0,1,2,...

document_id parent_id  space_id   name   type   path
3835   3834   1  1  2  0,1,3834
3836   3834   1  2  2  0,1,3834
3837   3836   1  1  1  0,1,3834,3836
3838   3835   1  3  1  0,1,3834,3835
3839   3834   1  3  2  0,1,3834
3840   3839   1  4  2  0,1,3834,3839
3841   3840   1  2  1  0,1,3834,3839,3840
```

1、参考` app\models\document.go` 数据库实现方法, 输入空间ID, 输出该空间下所有目录、目录下文档及子目录和子目录下文档、子目录下子目录和相应文档等等的所有文档ID, 并返回所有目录和文档的数量

2、在 `app\controllers\document.go`中实现该方法

导入模块

```
import (
	"strconv"
)
```

在`app\controllers\document.go`创建查询函数

```
// 获取空间下所有文档ID
func (this *DocumentController) GetInSpaceDocumentId(spaceId string, parentId string) (documentIds []string, total int, err error) {
    
    // 如果父目录ID不为0，先添加父目录ID
    if parentId != "0" {
        documentIds = append(documentIds, parentId)
        total++
    }

    // 获取空间下指定父目录的所有文档
    documents, err := models.DocumentModel.GetDocumentsBySpaceIdAndParentId(spaceId, parentId)
    if err != nil {
        return
    }

    // 递归获取所有子文档
    var getAllSubDocuments func(parentId string) error
    getAllSubDocuments = func(parentId string) error {
        // 获取当前目录下的所有文档
        subDocuments, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return err
        }

        for _, doc := range subDocuments {
            documentIds = append(documentIds, doc["document_id"])
            total++

            // 如果是目录，递归获取子文档
            if doc["type"] == strconv.Itoa(models.Document_Type_Dir) {
                err = getAllSubDocuments(doc["document_id"])
                if err != nil {
                    return err
                }
            }
        }
        return nil
    }

    // 从指定父目录开始遍历
    for _, doc := range documents {
        documentIds = append(documentIds, doc["document_id"])
        total++

        // 如果是目录，递归获取子文档
        if doc["type"] == strconv.Itoa(models.Document_Type_Dir) {
            err = getAllSubDocuments(doc["document_id"])
            if err != nil {
                return
            }
        }
    }

    return
}

// 获取空间下所有文档ID及数量
func (this *DocumentController) GetAllDocumentIdsInSpace() {
    spaceId := this.GetString("space_id", "0")
    parentId := this.GetString("parent_id", "0")
    // 验证空间ID
    if spaceId == "" || spaceId == "0" {
        this.jsonError("无效的空间ID")
        return
    }
    // 验证空间是否存在
    space, err := models.SpaceModel.GetSpaceBySpaceId(spaceId)
    if err != nil {
        this.jsonError(fmt.Sprintf("获取空间信息失败: %s", err.Error()))
        return
    }
    if len(space) == 0 {
        this.jsonError("空间不存在")
        return
    }
	// 检查访问权限
    isVisit, _, _ := this.GetDocumentPrivilege(space)
    if !isVisit {
        this.jsonError("您没有权限访问该空间")
        return
    }
    // 如果指定了父目录，验证父目录是否存在
    if parentId != "0" {
        parentDoc, err := models.DocumentModel.GetDocumentByDocumentId(parentId)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取父目录信息失败: %s", err.Error()))
            return
        }
        if len(parentDoc) == 0 {
            this.jsonError("父目录不存在")
            return
        }
        // 验证父目录是否属于指定空间
        if parentDoc["space_id"] != spaceId {
            this.jsonError("父目录不属于当前空间")
            return
        }
        // 验证指定的父ID是否为目录类型
        if parentDoc["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
            this.jsonError("指定的父级不是目录")
            return
        }
    }

    // 获取所有文档ID
    documentIds, total, err := this.GetInSpaceDocumentId(spaceId, parentId)
    if err != nil {
        this.jsonError(fmt.Sprintf("获取文档列表失败: %s", err.Error()))
        return
    }
    // 检查是否有文档
    if len(documentIds) == 0 {
        this.jsonSuccess("success", map[string]interface{}{
            "document_ids": []string{},
            "total":        0,
            "empty":        true,
        }, "")
        return
    }

    this.jsonSuccess("success", map[string]interface{}{
        "document_ids": documentIds,
        "total":        total,
    }, "")
}
```



### 调用方式

1. 发送 GET请求到 `/document/getAllDocumentIdsInSpace`

2. 参数：
   - `parent_id`: 父目录 ID，如果不传则默认为"0"。如果传入 parentId 为 "0" ，则相当于获取整个空间下的所有文档。
   
   - `space_id`: 空间 ID

示例调用：

```bash
curl "http://localhost:8080/document/getAllDocumentIdsInSpace?space_id=1&parent_id=2"
```



## 递归删除目录下的所有目录和文件

在`app\controllers\document.go`新建一个函数`DeleteAllDocumentIdsInSpace`

```
// 删除空间下所有文档ID及数量（可指定父目录）
func (this *DocumentController) DeleteAllDocumentIdsInSpace() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    spaceId := this.GetString("space_id", "0")
    parentId := this.GetString("parent_id", "0")
    confirm := this.GetString("confirm", "false") // 添加确认参数
    deleteParent := this.GetString("delete_parent", "true")  // 添加新参数，默认为 "true"
    
    // 验证空间ID
    if spaceId == "" || spaceId == "0" {
        this.jsonError("无效的空间ID")
        return
    }

    // 获取空间信息
    space, err := models.SpaceModel.GetSpaceBySpaceId(spaceId)
    if err != nil {
        this.jsonError(fmt.Sprintf("获取空间信息失败: %s", err.Error()))
        return
    }
    if len(space) == 0 {
        this.jsonError("空间不存在")
        return
    }

    // 父目录有效性验证
    if parentId != "0" {
        parentDoc, err := models.DocumentModel.GetDocumentByDocumentId(parentId)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取父目录信息失败: %s", err.Error()))
            return
        }
        if len(parentDoc) == 0 {
            this.jsonError("父目录不存在")
            return
        }
        // 验证父目录是否属于指定空间
        if parentDoc["space_id"] != spaceId {
            this.jsonError("父目录不属于当前空间")
            return
        }
        // 验证指定的父ID是否为目录类型
        if parentDoc["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
            this.jsonError("指定的父级不是目录")
            return
        }
    }

    // 检查空间权限
    _, _, isManager := this.GetDocumentPrivilege(space)
    if !isManager {
        this.jsonError("您没有权限删除该空间下的文档")
        return
    }

    // 获取所有文档ID
    documentIds, total, err := this.GetInSpaceDocumentId(spaceId, parentId)
    if err != nil {
        this.jsonError(err.Error())
        return
    }

    // 如果不删除父目录，从documentIds中移除parentId
    if deleteParent == "false" && parentId != "0" {
        for i, id := range documentIds {
            if id == parentId {
                documentIds = append(documentIds[:i], documentIds[i+1:]...)
                total--
                break
            }
        }
    }
    // 如果没有确认，返回需要删除的文档数量和提示
    if confirm != "true" {
        // 获取父目录信息
        var parentInfo map[string]string
        if parentId != "0" {
            parentInfo, err = models.DocumentModel.GetDocumentByDocumentId(parentId)
            if err != nil {
                this.jsonError(fmt.Sprintf("获取父目录信息失败: %s", err.Error()))
                return
            }
        }
		parentName := "根目录"
        if parentInfo != nil {
            parentName = parentInfo["name"]
        }

        this.jsonSuccess("请确认删除操作", map[string]interface{}{
            "total":        total,
            "space_name":   space["name"],
            "space_id":     spaceId,
            "parent_id":    parentId,
            "parent_name":  parentName,
            "need_confirm": true,
        }, "")
        return
    }

    // 删除所有文档
    deletedCount := 0
    for _, documentId := range documentIds {
        document, err := models.DocumentModel.GetDocumentByDocumentId(documentId)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取文档 %s 信息失败: %s", documentId, err.Error()))
            return
        }
        if len(document) == 0 {
            continue
        }

        // 跳过空间根目录
        if document["parent_id"] == "0" {
            continue
        }

        _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(document)
        if err != nil {
            this.jsonError(fmt.Sprintf("获取文档 %s 文件路径失败: %s", documentId, err.Error()))
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(documentId, spaceId, this.UserId, pageFile, document["type"])
        if err != nil {
            this.jsonError(fmt.Sprintf("删除文档 %s 失败: %s", documentId, err.Error()))
            return
        }
        deletedCount++
    }

    this.jsonSuccess("删除成功", map[string]interface{}{
        "deleted_count": deletedCount,
        "space_id":     spaceId,
        "space_name":   space["name"],
        "parent_id":    parentId,
    }, "")
}
```

### 调用方式

1. 

2. 在未确认时返回需要删除的文档数量和空间名称，让用户明确知道将要删除的内容

3. 添加了 delete_parent可选参数，当 deleteParent 为 `false` 时，将保留父目录但删除其下的所有文档；当 deleteParent 为 `true` 时，将连同父目录一起删除。

4. 发送 POST 请求到 `/document/deleteAllDocumentIdsInSpace`

5. 参数：
   - `parent_id`: 父目录 ID

     如果不传则默认为"0"。如果传入 parentId 为 "0" ，则相当于获取整个空间下的所有文档。

   - `space_id`: 空间 ID

   - `confirm`: 是否执行删除操作（可选，默认为 false）

     在未确认时返回需要删除的文档数量和空间名称，让用户明确知道将要删除的内容

   - `delete_parent`: 是否保留父目录（可选，默认为 true）

     当 deleteParent 为 `false` 时，将保留父目录但删除其下的所有文档；

     当 deleteParent 为 `true` 时，将连同父目录一起删除。

示例调用：
第一次调用（获取删除信息）：

```bash
curl -X POST "http://localhost:8080/document/deleteAllDocumentIdsInSpace" -d "space_id=1&parent_id=2"
```
确认删除：

```bash
curl -X POST "http://localhost:8080/document/DeleteAllDocumentIdsInSpace" -d "space_id=1&parent_id=2&confirm=true"
```
这样设计可以防止误操作，确保用户明确知道将要删除的内容，并需要显式确认才能执行删除操作。

不删除父目录

```bash
# 如指定pid为222，会删除222内所有目录和文档，但不会删除父目录222，这个可以加入参数选择，默认不删除222
curl -X POST "http://localhost:8080//document/DeleteAllDocumentIdsInSpace?space_id=1&parent_id=4026&confirm=true&delete_parent=false"
```



# 20250412

## 移动目录数据

```
	修复位置: app\controllers\document.go
	修复关键词: 文档名称格式不正确！
	修复方法: 注释下面代码
if moveType != "next" && moveType != "prev" {
		if document["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
			this.jsonError("不能移动文档目录！")
		}
	}
```

这仅仅修改了后端代码，不能直接拖动，但可以通过发送数据包完成移动，如下：

```
将3740目录移动到3735下面

发送空POST数据包请求: /document/move?document_id=3740&target_id=3735
```

移动完成后服务器中相关目录也会进行移动，但移动后数据库索引没有改变，后续代码主要卡在索引这一步了。

先拿个简版凑合用用吧

### 移动所有目录和文档

在`app\controllers\document.go`新建一个函数`MoveDirectory`

```
// move document directory
func (this *DocumentController) MoveDirectory() {
	// 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    onlyDocs, _ := this.GetBool("only_docs", false)  // 添加新参数，默认为false

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }
    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 只有在不是仅移动文档的情况下才检查子目录
    if !onlyDocs {
        // 获取目标目录的完整路径信息
        targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
        for _, pathId := range targetPath {
            if pathId == sourceId {
                this.jsonError("不能将目录移动到其子目录中！")
            }
        }
        
        // 递归检查子目录
        var checkSubDirectories func(parentId string) error
        checkSubDirectories = func(parentId string) error {
            subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
            if err != nil {
                return err
            }
            for _, doc := range subDocs {
                if doc["document_id"] == targetId {
                    return fmt.Errorf("目标目录是源目录的子目录")
                }
                if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    if err := checkSubDirectories(doc["document_id"]); err != nil {
                        return err
                    }
                }
            }
            return nil
        }
        
        if err := checkSubDirectories(sourceId); err != nil {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents": 0,
        "directories": 0,
        "skipped": 0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
            // 如果只移动文档且当前项是目录，则跳过
            if onlyDocs && doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                movedStats["skipped"]++
                continue
            }

            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"], 
                targetId, 
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]
                
                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newPath := targetPath + "," + targetId
                        err = moveRecursively(subDocs, utils.Convert.IntToString(newDirId, 10), newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录前检查是否还有文档
                subDocs, err := models.DocumentModel.GetDocumentsByParentId(sourceDirectoryId)
                if err != nil {
                    return fmt.Errorf("检查源目录文档失败: %v", err)
                }
                if len(subDocs) > 0 {
                    this.InfoLog(fmt.Sprintf("目录 %s 中还有文档，跳过删除", sourceDirectoryId))
                    continue
                }
            
                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
            
                continue
            }

            // 处理文档：如果存在同名文档，添加时间戳后缀
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            // 处理文档
            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "name":         doc["name"],
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"], 
                targetSpaceId, 
                updateValue,
                oldPageFile, 
                newPageFile, 
                doc["type"], 
                "移动文档到 " + targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, targetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        // 添加更详细的错误信息到响应
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 移动完成后删除源目录
    _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
    if err != nil {
        this.ErrorLog("获取源目录文件失败：" + err.Error())
        this.jsonError(fmt.Sprintf("获取源目录文件失败：%s", err.Error()))
        return
    }
    
    // 检查源目录是否还有文档
    remainingDocs, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("检查源目录文档失败：" + err.Error())
        this.jsonError("检查源目录文档失败")
        return
    }
    if len(remainingDocs) > 0 {
        this.InfoLog(fmt.Sprintf("源目录 %s 中还有文档，跳过删除", sourceId))
        this.jsonSuccess("移动目录成功，源目录因还有文档而保留", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
            "warning": "源目录中还有文档，已保留",
        }, "/document/index?document_id="+targetId)
        return
    }

    // 添加源目录存在性检查
    checkDoc, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("检查源目录失败：" + err.Error())
        this.jsonError("检查源目录失败")
        return
    }
    if len(checkDoc) == 0 {
        this.InfoLog("源目录已被删除，跳过删除步骤")
        this.jsonSuccess("移动目录成功", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
        }, "/document/index?document_id="+targetId)
        return
    }
    
    err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
    if err != nil {
        this.ErrorLog("删除源目录失败：" + err.Error())
        // 即使删除源目录失败，移动操作已经完成，返回成功
        this.jsonSuccess("移动目录成功，但删除源目录失败", map[string]interface{}{
            "moved_documents": movedStats["documents"],
            "moved_directories": movedStats["directories"],
            "source_space": sourceSpace["name"],
            "target_space": targetSpace["name"],
            "warning": "源目录删除失败：" + err.Error(),
        }, "/document/index?document_id="+targetId)
        return
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录", 
        sourceId, 
        movedStats["documents"], 
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents": movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "source_space": sourceSpace["name"],
        "target_space": targetSpace["name"],
    }, "/document/index?document_id="+targetId)
}
```

#### 调用方式

1. 发送 POST 请求到 `/document/MoveDirectory`

2. 参数：
   - `source_id`: 源目录ID
   
   - `target_id`: 目标目录 ID
   
   - `only_docs`: 是否仅移动文档（可选，默认为 false）

示例调用

```bash
# 正常情况：将目录123移动到目录456下，移动完成后删除源目录，如果源目录与目标目录有项目名称文件则会跳过并无法删除源目录
curl -X POST http://localhost:8080/document/MoveDirectory -d "source_id=123&target_id=456"

# 仅移动目录内的文档到另一个目录，如果目录内存在子目录则直接跳过
# 默认是不允许将目录移动到其子目录中，这可能将造成循环引用的问题，但如果选择仅移动文档的话是允许的
curl -X POST http://localhost:8080/document/MoveDirectory -d "source_id=123&target_id=456&only_docs=true"
```

### 移动所有目录和文档-指定模式（有bug）

```
我希望将目录aaaa移动到目录BBB下，有两种情况
1、将aaaa内所有子目录及文档移动到BBB下，目前已经实现
2、将aaaa目录包含本身及其子目录和文档移动到BBB下，索引问题暂未实现
```

在`app\controllers\document.go`新建一个函数`MoveDirectoryAll`

#### v1版本

```
// move document directory all
func (this *DocumentController) MoveDirectoryAll() {
	// 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    onlyDocs, _ := this.GetBool("only_docs", false)  // 添加可选参数，默认为false
    moveMode := this.GetString("move_mode", "content") // 移动模式：content-仅移动内容，all-移动目录及内容

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }
    if moveMode != "content" && moveMode != "all" {
        this.jsonError("无效的移动模式！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }

    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 只有在不是仅移动文档的情况下才检查子目录
    if !onlyDocs {
        // 获取目标目录的完整路径信息
        targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
        for _, pathId := range targetPath {
            if pathId == sourceId {
                this.jsonError("不能将目录移动到其子目录中！")
            }
        }
        
        // 递归检查子目录
        var checkSubDirectories func(parentId string) error
        checkSubDirectories = func(parentId string) error {
            subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
            if err != nil {
                return err
            }
            for _, doc := range subDocs {
                if doc["document_id"] == targetId {
                    return fmt.Errorf("目标目录是源目录的子目录")
                }
                if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    if err := checkSubDirectories(doc["document_id"]); err != nil {
                        return err
                    }
                }
            }
            return nil
        }
        
        if err := checkSubDirectories(sourceId); err != nil {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }

    // 如果是移动整个目录，先创建源目录在目标位置
    var newTargetId string = targetId
    if moveMode == "all" {
        // 检查目标位置是否存在同名目录
        existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
            sourceDocument["name"],
            targetId,
            targetSpaceId,
            models.Document_Type_Dir)
        if err != nil {
            this.ErrorLog("检查目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        if len(existingDoc) > 0 {
            this.jsonError("目标位置已存在同名目录！")
        }

        // 创建新目录
        insertDoc := map[string]interface{}{
            "parent_id":      targetId,
            "space_id":       targetSpaceId,
            "name":           sourceDocument["name"],
            "type":           models.Document_Type_Dir,
            "path":           targetDocument["path"] + "," + targetId,
            "create_user_id": this.UserId,
            "edit_user_id":   this.UserId,
        }
        newDirId, err := models.DocumentModel.Insert(insertDoc)
        if err != nil {
            this.ErrorLog("创建目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        newTargetId = utils.Convert.IntToString(newDirId, 10)
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents":    0,
        "directories": 0,
        "skipped":     0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
        	// 如果只移动文档且当前项是目录，则跳过
            if onlyDocs && doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                movedStats["skipped"]++
                continue
            }
            
            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"],
                targetId,
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]

                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                    movedStats["skipped"]++
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newPath := targetPath + "," + targetId
                        err = moveRecursively(subDocs, utils.Convert.IntToString(newDirId, 10), newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
                continue
            }

            // 处理文档
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"],
                targetSpaceId,
                updateValue,
                oldPageFile,
                newPageFile,
                doc["type"],
                "移动文档到 "+targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, newTargetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 如果是仅移动内容模式，删除源目录
    if moveMode == "content" {
        _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
        if err != nil {
            this.ErrorLog("获取源目录文件失败：" + err.Error())
            this.jsonError("获取源目录文件失败")
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
        if err != nil {
            this.ErrorLog("删除源目录失败：" + err.Error())
            this.jsonError("删除源目录失败")
            return
        }
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录",
        sourceId,
        movedStats["documents"],
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents":    movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "skipped":          movedStats["skipped"],
        "source_space":     sourceSpace["name"],
        "target_space":     targetSpace["name"],
        "move_mode":        moveMode,
    }, "/document/index?document_id="+newTargetId)
}

```

#### v2版本

```
// move document directory all
func (this *DocumentController) MoveDirectoryAll() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    sourceId := this.GetString("source_id", "0")
    targetId := this.GetString("target_id", "0")
    moveMode := this.GetString("move_mode", "content") // 移动模式：content-仅移动内容，all-移动目录及内容

    if sourceId == "0" {
        this.jsonError("没有选择源目录！")
    }
    if targetId == "0" {
        this.jsonError("没有选择目标目录！")
    }
    if moveMode != "content" && moveMode != "all" {
        this.jsonError("无效的移动模式！")
    }

    sourceDocument, err := models.DocumentModel.GetDocumentByDocumentId(sourceId)
    if err != nil {
        this.ErrorLog("查找源目录失败：" + err.Error())
        this.jsonError("查找源目录失败！")
    }
    if len(sourceDocument) == 0 {
        this.jsonError("源目录不存在！")
    }
    if sourceDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("源文档不是目录！")
    }

    targetDocument, err := models.DocumentModel.GetDocumentByDocumentId(targetId)
    if err != nil {
        this.ErrorLog("查找目标目录失败：" + err.Error())
        this.jsonError("查找目标目录失败！")
    }
    if len(targetDocument) == 0 {
        this.jsonError("目标目录不存在！")
    }
    if targetDocument["type"] != fmt.Sprintf("%d", models.Document_Type_Dir) {
        this.jsonError("目标文档必须是目录！")
    }

    // 获取源空间和目标空间信息
    sourceSpaceId := sourceDocument["space_id"]
    targetSpaceId := targetDocument["space_id"]
    sourceSpace, err := models.SpaceModel.GetSpaceBySpaceId(sourceSpaceId)
    if err != nil {
        this.ErrorLog("获取源空间信息失败：" + err.Error())
        this.jsonError("获取源空间信息失败！")
    }
    targetSpace, err := models.SpaceModel.GetSpaceBySpaceId(targetSpaceId)
    if err != nil {
        this.ErrorLog("获取目标空间信息失败：" + err.Error())
        this.jsonError("获取目标空间信息失败！")
    }

    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(sourceSpace)
    if !isEditor {
        this.jsonError("您没有权限移动该空间下的目录！")
    }

    // 检查是否移动到自身或其子目录
    if sourceId == targetId {
        this.jsonError("不能将目录移动到自身！")
    }
    
    // 获取目标目录的完整路径信息
    targetPath := strings.Split(targetDocument["path"]+","+targetId, ",")
    for _, pathId := range targetPath {
        if pathId == sourceId {
            this.jsonError("不能将目录移动到其子目录中！")
        }
    }
    
    // 递归检查子目录
    var checkSubDirectories func(parentId string) error
    checkSubDirectories = func(parentId string) error {
        subDocs, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return err
        }
        for _, doc := range subDocs {
            if doc["document_id"] == targetId {
                return fmt.Errorf("目标目录是源目录的子目录")
            }
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                if err := checkSubDirectories(doc["document_id"]); err != nil {
                    return err
                }
            }
        }
        return nil
    }
    
    if err := checkSubDirectories(sourceId); err != nil {
        this.jsonError("不能将目录移动到其子目录中！")
    }

    // 如果是移动整个目录，先创建源目录在目标位置
    var newTargetId string = targetId
    if moveMode == "all" {
        // 检查目标位置是否存在同名目录
        existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
            sourceDocument["name"],
            targetId,
            targetSpaceId,
            models.Document_Type_Dir)
        if err != nil {
            this.ErrorLog("检查目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        if len(existingDoc) > 0 {
            this.jsonError("目标位置已存在同名目录！")
        }

        // 创建新目录
        insertDoc := map[string]interface{}{
            "parent_id":      targetId,
            "space_id":       targetSpaceId,
            "name":           sourceDocument["name"],
            "type":           models.Document_Type_Dir,
            "path":           targetDocument["path"] + "," + targetId,
            "create_user_id": this.UserId,
            "edit_user_id":   this.UserId,
        }
        newDirId, err := models.DocumentModel.Insert(insertDoc)
        if err != nil {
            this.ErrorLog("创建目标目录失败：" + err.Error())
            this.jsonError("移动目录失败！")
        }
        newTargetId = utils.Convert.IntToString(newDirId, 10)
    }

    // 获取源目录下的所有文档和目录
    documents, err := models.DocumentModel.GetDocumentsByParentId(sourceId)
    if err != nil {
        this.ErrorLog("获取源目录下的文档失败：" + err.Error())
        this.jsonError("获取源目录下的文档失败！")
    }

    movedStats := map[string]int{
        "documents":    0,
        "directories": 0,
        "skipped":     0,
    }

    // 递归移动文档和目录的函数
    var moveRecursively func(docs []map[string]string, targetId string, targetPath string) error
    moveRecursively = func(docs []map[string]string, targetId string, targetPath string) error {
        for _, doc := range docs {
            // 检查目标位置是否存在同名文档
            existingDoc, err := models.DocumentModel.GetDocumentByNameParentIdAndSpaceId(
                doc["name"],
                targetId,
                targetSpaceId,
                utils.Convert.StringToInt(doc["type"]))
            if err != nil {
                return err
            }

            // 处理目录
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                sourceDirectoryId := doc["document_id"]

                if len(existingDoc) > 0 {
                    // 如果存在同名目录，直接使用目标目录
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = moveRecursively(subDocs, existingDoc["document_id"], existingDoc["path"])
                        if err != nil {
                            return err
                        }
                    }
                    movedStats["skipped"]++
                } else {
                    // 不存在同名目录，创建新目录
                    insertDoc := map[string]interface{}{
                        "parent_id":      targetId,
                        "space_id":       targetSpaceId,
                        "name":           doc["name"],
                        "type":           models.Document_Type_Dir,
                        "path":           targetPath + "," + targetId,
                        "create_user_id": this.UserId,
                        "edit_user_id":   this.UserId,
                    }
                    newDirId, err := models.DocumentModel.Insert(insertDoc)
                    if err != nil {
                        return err
                    }
                    movedStats["directories"]++

                    // 递归处理子文档
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(doc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        newDirIdStr := utils.Convert.IntToString(newDirId, 10)
                        newPath := targetPath + "," + targetId + "," + newDirIdStr
                        err = moveRecursively(subDocs, newDirIdStr, newPath)
                        if err != nil {
                            return err
                        }
                    }
                }

                // 删除源目录
                _, pageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
                if err != nil {
                    return err
                }
                err = models.DocumentModel.DeleteDBAndFile(sourceDirectoryId, targetSpaceId, this.UserId, pageFile, doc["type"])
                if err != nil {
                    return fmt.Errorf("删除源目录失败: %v", err)
                }
                continue
            }

            // 处理文档
            if len(existingDoc) > 0 {
                movedStats["skipped"]++
                continue
            }

            _, oldPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(doc)
            if err != nil {
                return err
            }

            newDoc := map[string]string{
                "space_id":  targetSpaceId,
                "parent_id": targetId,
                "name":      doc["name"],
                "type":      doc["type"],
                "path":      targetPath + "," + targetId,
            }
            _, newPageFile, err := models.DocumentModel.GetParentDocumentsByDocument(newDoc)
            if err != nil {
                return err
            }

            updateValue := map[string]interface{}{
                "space_id":     targetSpaceId,
                "parent_id":    targetId,
                "path":         targetPath + "," + targetId,
                "edit_user_id": this.UserId,
            }
            _, err = models.DocumentModel.MoveDBAndFile(
                doc["document_id"],
                targetSpaceId,
                updateValue,
                oldPageFile,
                newPageFile,
                doc["type"],
                "移动文档到 "+targetDocument["name"])
            if err != nil {
                return err
            }
            movedStats["documents"]++
        }
        return nil
    }

    // 开始递归移动
    err = moveRecursively(documents, newTargetId, targetDocument["path"])
    if err != nil {
        this.ErrorLog("移动目录失败：" + err.Error())
        this.jsonError(fmt.Sprintf("移动目录失败：%s", err.Error()))
        return
    }

    // 递归更新所有文档的索引
    var updateIndexRecursively func(docs []map[string]string) error
    updateIndexRecursively = func(docs []map[string]string) error {
        for _, doc := range docs {
            // 获取最新的文档信息
            updatedDoc, err := models.DocumentModel.GetDocumentByDocumentId(doc["document_id"])
            if err != nil {
                return err
            }
            if len(updatedDoc) > 0 {
                // 更新当前文档的索引
                services.DocIndexService.UpdateDocIndex(updatedDoc)

                // 如果是目录，获取其下所有文档
                if updatedDoc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                    subDocs, err := models.DocumentModel.GetDocumentsByParentId(updatedDoc["document_id"])
                    if err != nil {
                        return err
                    }
                    if len(subDocs) > 0 {
                        err = updateIndexRecursively(subDocs)
                        if err != nil {
                            return err
                        }
                    }
                }
            }
        }
        return nil
    }

    // 开始更新索引
    if moveMode == "all" {
        // 获取新目录下的所有文档
        newDocs, err := models.DocumentModel.GetDocumentsByParentId(newTargetId)
        if err != nil {
            this.ErrorLog("获取新目录文档失败：" + err.Error())
        } else {
            // 先更新目标目录本身
            targetDoc, _ := models.DocumentModel.GetDocumentByDocumentId(newTargetId)
            if len(targetDoc) > 0 {
                services.DocIndexService.UpdateDocIndex(targetDoc)
            }
            // 更新所有子文档
            err = updateIndexRecursively(newDocs)
            if err != nil {
                this.ErrorLog("更新文档索引失败：" + err.Error())
            }
        }
    } else {
        // content 模式下更新目标目录下的文档
        targetDocs, err := models.DocumentModel.GetDocumentsByParentId(targetId)
        if err != nil {
            this.ErrorLog("获取目标目录文档失败：" + err.Error())
        } else {
            err = updateIndexRecursively(targetDocs)
            if err != nil {
                this.ErrorLog("更新文档索引失败：" + err.Error())
            }
        }
    }
    // 如果是仅移动内容模式，删除源目录
    if moveMode == "content" {
        _, sourcePageFile, err := models.DocumentModel.GetParentDocumentsByDocument(sourceDocument)
        if err != nil {
            this.ErrorLog("获取源目录文件失败：" + err.Error())
            this.jsonError("获取源目录文件失败")
            return
        }

        err = models.DocumentModel.DeleteDBAndFile(sourceId, sourceSpaceId, this.UserId, sourcePageFile, sourceDocument["type"])
        if err != nil {
            this.ErrorLog("删除源目录失败：" + err.Error())
            this.jsonError("删除源目录失败")
            return
        }
    }

    this.InfoLog(fmt.Sprintf("移动目录 %s 成功：已移动 %d 个文档和 %d 个目录",
        sourceId,
        movedStats["documents"],
        movedStats["directories"]))

    this.jsonSuccess("移动目录成功", map[string]interface{}{
        "moved_documents":    movedStats["documents"],
        "moved_directories": movedStats["directories"],
        "skipped":          movedStats["skipped"],
        "source_space":     sourceSpace["name"],
        "target_space":     targetSpace["name"],
        "move_mode":        moveMode,
    }, "/document/index?document_id="+newTargetId)
}
```

#### 调用方式

1. 发送 POST 请求到 `/document/MoveDirectoryAll`

2. 参数：
   - `source_id`: 源目录ID
   
   - `target_id`: 目标目录 ID
   
   - `move_mode `: 移动模式（可选，默认为 content）
   
     content：将123内的所有内容移动到456并删除123目录
   
     all：将123目录包含本身及其子目录和文档移动到456下

示例调用

```bash
# 正常情况：将目录123移动到目录456下
curl -X POST http://localhost:8080/document/MoveDirectoryAll -d "source_id=123&target_id=456&move_mode=all"
```

#### bug

- content正常使用
- 选择all模式时，索引异常-未解决



## 数据库中document表 path 字段的长度限制

原本30，调整为150

# 20250426

## 对指定目录下的文档和目录进行排序

在`app\controllers\document.go`新建一个函数`SortDocuments`

```
// SortDocuments 按名称对指定父目录下的文档和目录进行排序
func (this *DocumentController) SortDocuments() {
    // 检查请求方法
    if !this.IsPost() {
        this.jsonError("请求方式有误！")
        return
    }
    
    // 获取参数
    parentId := this.GetString("parent_id", "0")
    spaceId := this.GetString("space_id", "0")
    recursive, _ := this.GetBool("recursive", false)  // 是否递归排序子目录
    
    if parentId == "0" {
        this.jsonError("没有选择父目录！")
        return
    }
    if spaceId == "0" {
        this.jsonError("没有选择空间！")
        return
    }
    
    // 验证父目录是否存在
    parentDoc, err := models.DocumentModel.GetDocumentByDocumentId(parentId)
    if err != nil {
        this.ErrorLog("获取父目录信息失败：" + err.Error())
        this.jsonError("获取父目录信息失败！")
        return
    }
    if len(parentDoc) == 0 {
        this.jsonError("父目录不存在！")
        return
    }
    
    // 验证父目录是否属于指定空间
    if parentDoc["space_id"] != spaceId {
        this.jsonError("父目录不属于当前空间！")
        return
    }
    
    // 验证空间是否存在
    space, err := models.SpaceModel.GetSpaceBySpaceId(spaceId)
    if err != nil {
        this.ErrorLog("获取空间信息失败：" + err.Error())
        this.jsonError("获取空间信息失败！")
        return
    }
    if len(space) == 0 {
        this.jsonError("空间不存在！")
        return
    }
    
    // 检查空间权限
    _, isEditor, _ := this.GetDocumentPrivilege(space)
    if !isEditor {
        this.jsonError("您没有权限在该空间下排序文档！")
        return
    }
    
    // 定义递归排序函数
    var sortDocumentsRecursively func(parentId string) (int, error)
    sortDocumentsRecursively = func(parentId string) (int, error) {
        // 获取父目录下的所有文档
        documents, err := models.DocumentModel.GetDocumentsByParentId(parentId)
        if err != nil {
            return 0, err
        }
        
        // 按类型和名称排序：先目录后文档，每种类型内按名称排序
        dirDocs := []map[string]string{}
        pageDocs := []map[string]string{}
        
        // 分离目录和文档
        for _, doc := range documents {
            if doc["type"] == fmt.Sprintf("%d", models.Document_Type_Dir) {
                dirDocs = append(dirDocs, doc)
            } else {
                pageDocs = append(pageDocs, doc)
            }
        }
        
        // 对目录按名称排序
        sort.Slice(dirDocs, func(i, j int) bool {
            return strings.ToLower(dirDocs[i]["name"]) < strings.ToLower(dirDocs[j]["name"])
        })
        
        // 对文档按名称排序
        sort.Slice(pageDocs, func(i, j int) bool {
            return strings.ToLower(pageDocs[i]["name"]) < strings.ToLower(pageDocs[j]["name"])
        })
        
        // 合并排序后的目录和文档
        sortedDocs := append(dirDocs, pageDocs...)
        
        // 更新文档的sequence字段
        for i, doc := range sortedDocs {
            sequence := i + 1 // 序号从1开始
            _, err := models.DocumentModel.Update(doc["document_id"], map[string]interface{}{
                "sequence": sequence,
                "edit_user_id": this.UserId,
            }, fmt.Sprintf("修改文档排序"), spaceId)
            if err != nil {
                return 0, err
            }
        }
        
        // 如果需要递归排序，则处理所有子目录
        totalSorted := len(sortedDocs)
        if recursive {
            for _, doc := range dirDocs {
                // 递归处理子目录
                subSorted, err := sortDocumentsRecursively(doc["document_id"])
                if err != nil {
                    return 0, err
                }
                totalSorted += subSorted
            }
        }
        
        return totalSorted, nil
    }
    
    // 执行排序
    totalSorted, err := sortDocumentsRecursively(parentId)
    if err != nil {
        this.ErrorLog("文档排序失败：" + err.Error())
        this.jsonError("文档排序失败！")
        return
    }
    
    this.InfoLog("文档排序成功，共排序 " + strconv.Itoa(totalSorted) + " 个文档")
    this.jsonSuccess("文档排序成功", map[string]interface{}{
        "count": totalSorted,
        "recursive": recursive,
    }, "")
}
```

### 调用方式

1. 发送 POST 请求到 `/document/SortDocuments`
2. 参数：
   - `parent_id`: 父目录 ID
   - `space_id`: 空间 ID
   - `recursive`: 是否递归排序子目录（可选，默认为 false）

示例调用：

```bash
# 基本的文档排序
curl -X POST "http://localhost:8080/document/SortDocuments" -d "space_id=1&parent_id=2"

# 递归处理子目录，先显示目录，再显示文档，每种类型内部按名称字母顺序排序
curl -X POST "http://localhost:8080/document/SortDocuments" -d "space_id=1&parent_id=2&recursive=true"
```

# 20250428

## 图片信息保存失败

根据错误信息 ` 上传图片保存信息错误: Error 1406: Data too long for column 'name' at row 1` ，这是一个典型的MySQL数据库错误，表示您尝试插入的数据超过了数据库表中'name'列的最大长度限制。

在 `image.go` 文件中，当上传图片时，系统会将图片的原始文件名直接存储到数据库的 attachment 表的 name 字段中

```
attachment := map[string]interface{}{
    "user_id":     this.UserId,
    "document_id": documentId,
    "name":        h.Filename,  // 这里直接使用了原始文件名
    "path":        fmt.Sprintf("images/%s/%s/%s", spaceId, documentId, h.Filename),
    "source":      models.Attachment_Source_Image,
}
```

问题在于，用户上传的图片文件名可能非常长，超过了数据库 name 字段的长度限制。

改进：

- 1、生成一个唯一的文件名，而不是使用原始文件名

`app\controllers\image.go`

导入所需模块

```
import (
	"time"	// 添加time包的导入
	"math/rand" // 添加随机数包
)
```

添加代码

```
// ... existing code ...
	// handle upload
	f, h, err := this.GetFile("editormd-image-file")
	if err != nil {
		this.ErrorLog("上传图片数据错误: " + err.Error())
		this.jsonError("上传图片数据错误")
		return
	}
	if h == nil || f == nil {
		this.ErrorLog("上传图片错误")
		this.jsonError("上传图片错误")
		return
	}
	_ = f.Close()

	// 生成唯一文件名
	ext := path.Ext(h.Filename)
	// 使用时间戳+随机字符串生成唯一文件名，文件名格式为： 时间戳_随机字符串.扩展名
	rand.Seed(time.Now().UnixNano())
	const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	randomStr := make([]byte, 6)  // 将长度从4改为6
	for i := 0; i < 6; i++ {      // 将循环次数从4改为6
		randomStr[i] = chars[rand.Intn(len(chars))]
	}
	
	uniqueFilename := fmt.Sprintf("%d_%s%s", time.Now().Unix(), string(randomStr), ext)

	// file save dir
	saveDir := fmt.Sprintf("%s/%s/%s", app.ImageAbsDir, spaceId, documentId)
	ok, _ := utils.File.PathIsExists(saveDir)
	if !ok {
		err := os.MkdirAll(saveDir, 0777)
		if err != nil {
			this.ErrorLog("上传图片错误: " + err.Error())
			this.jsonError("上传图片失败")
			return
		}
	}
	// check file is exists
	imageFile := path.Join(saveDir, uniqueFilename)
	ok, _ = utils.File.PathIsExists(imageFile)
	if ok {
		this.jsonError("该图片已经上传过！")
	}
	// save file
	err = this.SaveToFile("editormd-image-file", imageFile)
	if err != nil {
		this.ErrorLog("图片保存失败: " + err.Error())
		this.jsonError("图片保存失败")
	}

	// insert db
	attachment := map[string]interface{}{
		"user_id":     this.UserId,
		"document_id": documentId,
		"name":        uniqueFilename,
		"path":        fmt.Sprintf("images/%s/%s/%s", spaceId, documentId, uniqueFilename),
		"source":      models.Attachment_Source_Image,
	}
```

- 2、修改数据库表结构

  修改数据库中attachment表 name  字段的长度限制

  原本50，调整为150

## 附件显示图片名称

`views\attachment\image.html`

```
// ... existing code ...
<td class="text-left"><strong>图片</strong></td>
<td class="w15p text-left"><strong>名称</strong></td>
<td class="w15p text-left"><strong>上传用户</strong></td>
<td class="w20p text-left"><strong>上传时间</strong></td>
<td class="w11p center"><strong>操作</strong></td>

// ... existing code ...
<td>{{$attachment.name}}</td>
<td>{{$attachment.username}}</td>
<td>{{dateFormat $attachment.create_time "Y-m-d H:i:s"}}</td>
// ... existing code ...
```

